

Webdriver , PageFactory, Wait, FluentWait, WebDriverWait, JavascriptExecutor, TakesScreenshot, 

Page Object Model, also known as POM, is a design pattern in Selenium that creates an object repository for storing all web elements. It is useful in reducing code duplication and improves test case maintenance

===============

Advantages:
	- Open source
	- Multiple languages
	- Multiple browser
	- Multiple operating systems
	- Supports paralllel testing
	- Can integrate third party tools , TestNG, Cucumber, Maven, Jenknins, Git


Disadvantages
	- Only web based applications
	- No reportin
	- No dediicated support (open source)
	- No image based testing (can find image width, lenthy )

=======
How to Handle Authentication Popup in Selenium Web Driver? -- coming from Windows Autentication

	Best way is incluede credentials in the url :

	http://username:password@hotmail.co,

=======
Headless Browser Testing in Selenium with Java
	ChromeOptions options = new ChromeOptions();
	options.addArguments("--headless");
	// options.setHeadless(true)

	or Can use custom class developed in java --> HTMLUnitDriver  ---> get jar dependecy and use it

=============
How to find Broken links using Selenium WebDriver
	- Find all links --> List<Webelement> links = By.tag("a")
	- String url = links[i].getAtrribute("href")
	- URL link = new URL(url)

	- HttpURLConnection httpConn = (HttpURLConnection) link.openConnection()
	  httpConn.connect()

	  int reSPOMSEcODE = httpConn.getResponseCode() --> if 400 url is broken


=========
Handling Cookies in Selenium 
	Cookie coooki = new Cookie("lan", "tr");
	
	driver.manage().getCookies()
	driver.manage().getCookieNamed(cookie)
	driver.manage().addCookie(cookie)

	driver.manage().deleteCookie(cookie)
	driver.manage().deleteCookieNamed(cookie)
	driver.manage().deleteAllCookies()

========
How to Encode Password in Selenium using Java || Password Encryption in Java

	- use a utiliy method to encode the decryted password written in sendKeys(decodeMethod)

		method takes "adadaa32===="  ---> returns  new String (Base64.decodeBase64("adadaa32===="))


=========

How to automate BarCode using ZXing API in Selenium
  - uing 3rd party tool ZXing

========
What do you value most in a company?
	Profesional growth
	Salary and Benefits
	Culture and Values
	Wprk -Life balance
	Recognition and Support


==========
Use the STAR Method Whenever You Can
	STAR stands for the Situation, Task, Action, and Result. STAR is a structured method of answering interview questions and ensures that you will cover each facet of the problem. It’s wise to have an organized, consistent structure to your answers, and the STAR method is one of the better ways to keep you focused.

========

isDisplayed(), isEnabled() and isSelected() 


========
Page Loading Strategy in Selenium Webdriver

	1.Normal  --> wait for  "load" event to be fired
		This command will make the web driver wait until the complete page gets loaded and this wait is looking for the load event to be fired .by default if we are not providing anything this will apply.

	2.Eager  --> wait for  "DOMContentLoaded" event to be fired
		If we are going to use Eager as a wait Strategy then webdriver will wait until the initial page gets loaded, this strategy won’t wait for loading of stylesheets, images, and subframes, In this WebDriver waits until the DOMContentLoaded event fire is returned.

	3. 3.None

			In this wait, Webdriver waits for initial page to be loaded

Ex: 
	ChromeOptions chromeOptions = new ChromeOptions(); 
	chromeOptions.setPageLoadStrategy(PageLoadStrategy.NORMAL); 
	WebDriver driver = new ChromeDriver(chromeOptions);


===========
driver first load page gets the dom and its version 1
once page is refreshed gets new dom and its version 2 all referenced in version 1 are lost ---> stale element


get(url) and navigate().to() same navigate has more methods to  go back forwrad and keeping the cookie but not the dom version
- get(url) waits for page load  navigate doesnt wait


It is usually necessary to introduce a wait time in the Selenium script when navigating Ajax-based or dynamic elements that may continue to load after the page loads.

Certain elements may only become visible after the page loads or after a user action but be available for interaction after a few seconds have passed. Think of a dropdown menu with dynamic values. It’s always available on the DOM, but its values are populated based on the user’s action.

=====================================================

System.setProperty("chrome.driver", path)
or
Bonnie Gatcias WebDriverMaanager


==================
Page Factory is a class provided by Selenium WebDriver to support Page Object Design patterns. 
In Page Factory, testers use @FindBy annotation. 
The initElements method is used to initialize web elements. 
Similarly, one can use @FindBy with different location strategies to find web elements and perform actions on them


ex:

	public DynamicLoad1Page(){
        PageFactory.initElements(Driver.getDriver(), this);
    }

    @FindBy(xpath = "//button[.='Start']")
    public WebElement startButton;

    @FindBy(id = "loading")
    public WebElement loadingBar;

    
==========

https://w3c.github.io/webdriver/#dfn-element-click-intercepted  ----> All exceptions and explanations


- No Such Element Exception :
	Likely Cause
		You are looking for the element in the wrong place (perhaps a previous action was unsuccessful).
		You are looking for the element at the wrong time (the element has not shown up in the DOM, yet)
		The locator has changed since you wrote the code

	Possible Solutions
		Make sure you are on the page you expect to be on, and that previous actions in your code completed correctly
		Make sure you are using a proper Waiting Strategy
		Update the locator with the browser’s devtools console or use a browser extension like: SelectorsHub

- Stale Element Reference Exception
	
	Common Causes
		You have refreshed the page, or the DOM of the page has dynamically changed.
		You have navigated to a different page.
		You have switched to another window or into or out of a frame or iframe.

	Common Solutions
		The DOM has changed

				When the page is refreshed or items on the page have moved around, there is still an element with the desired locator on the page, it is just no longer accessible by the element object being used, and the element must be relocated before it can be used again. This is often done in one of two ways:

					Always relocate the element every time you go to use it. The likelihood of the element going stale in the microseconds between locating and using the element is small, though possible. The downside is that this is not the most efficient approach, especially when running on a remote grid.

					Wrap the Web Element with another object that stores the locator, and caches the located Selenium element. When taking actions with this wrapped object, you can attempt to use the cached object if previously located, and if it is stale, exception can be caught, the element relocated with the stored locator, and the method re-tried. This is more efficient, but it can cause problems if the locator you’re using references a different element (and not the one you want) after the page has changed.

		The Context has changed

				Element objects are stored for a given context, so if you move to a different context — like a different window or a different frame or iframe — the element reference will still be valid, but will be temporarily inaccessible. In this scenario, it won’t help to relocate the element, because it doesn’t exist in the current context. To fix this, you need to make sure to switch back to the correct context before using the element.

		The Page has changed

				This scenario is when you haven’t just changed contexts, you have navigated to another page and have destroyed the context in which the element was located. You can’t just relocate it from the current context, and you can’t switch back to an active context where it is valid. If this is the reason for your error, you must both navigate back to the correct location and relocate it.


- Invalid Selector Exception

	Likely Cause
			The CSS or XPath selector you are trying to use has invalid characters or an invalid query.

	Possible Solutions
			Run your selector through a validator service:
					CSS Validator
					xPath Validator
					Or use a browser extension to get a known good value: SelectorsHub

- ElementClickInterceptedException:
	The element click command is executed on the center of the element. If the center of the element is obscured for some reason, Selenium will return an element click intercepted error.

	JavascriptExecutor.executeScript("argument[0].click()" , webElement)  ----> Solves the proble

	You’ll find this error mostly while using the Google Chrome browser but hardly ever while using the Firefox browser. The reason for this being common in the Chrome browser is because the Chrome driver always clicks in the middle of the element. So when you’re testing a dynamic application, there are chances that the element you want to click on isn’t at the exact location as expected.

========================
- direct click

JavascriptExecutor js = (JavascriptExecutor)driver;
js.executeScript("arguments[0].click();", element);

-------

- scroll to element and click

WebElement element = driver.findElement(element locator);
((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", element); 
element.click();


=========================
Interacting with web elements
	A high-level instruction set for manipulating form controls.
	There are only 5 basic commands that can be executed on an element:

		- click (applies to any element)
		- send keys (only applies to text fields and content editable elements)
		- clear (only applies to text fields and content editable elements)
		- submit (only applies to form elements)
		- select (see Select List Elements)




=================
Select is used just to select one or more dropdown options from that dropdown.
Two types of select --> single   : only one option is selecteable  --> No multiple attribute like below
						multiple : multiple option can be selectable. --> <select name="multi" id="multi" multiple="multiple">  notice multiple attribute

Select select = new Select(webelement) ---> dropdown if in html <select> <option value='value1'>text1</option> </select>
select.getOptions()  ---> list of all options
select.selectByVisibleText("Text");
select.selectByIndex(intIndex);
select.selectByValue("Value"); 

==============================================

Selenium file upload/download:
https://www.guru99.com/upload-download-file-selenium-webdriver.html

=========================================================

Set<String> allWindowIds = driver.getWindowHandles();


driver.switchTo().window(windowToBeSwitched);  other tab windows

driver.switchTo().frame(iframeelement);  iframes (ad, video, etc) in main frame
	
			driver.switchTo().parentFrame(); --> this will go back to the parent
			driver.switchTo().defaultContent(); --> this will go back to default html


Alert alert = driver.switchTo().alert()


===========================
There are 2 types of pop-ups or alerts
1. HTML pop-ups or alerts
2. JavaScript pop-ups or alerts
	There are 3 types of JavaScript alerts
		a.Warning / Information alert  --> Only alert.accept() 
		b.Confirmation alert --> alert.accept() and alert.dismiss()
		c.Prompt alert  ---> alert.sendKeys("text") + alert.accept() or alert.dismiss()

	Alert is an Interface . to get it --->  driver.switchTo().alert()
	Alert alert = driver.switchTo().alert();
	alert.accept();
	alert.dismiss();
	alert.sendKeys("text");
	alert.getText();

===============================
What does the switchTo() command do?
• switchTo() command is used to switch between windows, frames or pop-ups within the application

1 ---> driver.switchTo().window(windowToBeSwitched);  other tab windows

2 ---> driver.switchTo().frame(iframeelement);  iframes (ad, video, etc) in main frame
			driver.switchTo().parentFrame(); --> this will go back to the parent
			driver.switchTo().defaultContent(); --> this will go back to default html

3 --->Alert alert = driver.switchTo().alert()



======================================

It is very common to create some utility methods to handle tables in frameworks

	o You may create a method that takes a table web element as a parameter and returns all table column headers as a list
	o You may create another method that takes a table and returns all the data, or another method returns all data in a specific row

<table> <th> <td > / <tr> <td> / <tr> <td>   </table>

==========================================================================================================================================
Actions class ---> mouse

Keyboard, Mouse, Pen Wheel
---------------------------
Keyboard actions: 
	There are only 2 actions that can be accomplished with a keyboard: pressing down on a key, and releasing a pressed key
		Key down:
				new Actions(driver)
				.keyDown(Keys.SHIFT)
                .sendKeys("a")
                .perform();

		Key Up: 
				new Actions(driver)
                .keyDown(Keys.SHIFT)
                .sendKeys("a")
                .keyUp(Keys.SHIFT)
                .sendKeys("b")
                .perform();

        Send Keys: This is a convenience method in the Actions API that combines keyDown and keyUp commands in one action.
        		case : if we are on the active element 
		        		 new Actions(driver)
		                 .sendKeys("abc")
		                 .perform();

		        case : To target textField element
		        		new Actions(driver)
                		.sendKeys(textField, "Selenium!")
                		.perform();

					

WebElement clickable = driver.findElement(By.id("clickable"));

new Actions(driver).moveToElement(clickable)
	               .pause(Duration.ofSeconds(1))
	               .clickAndHold()
	               .pause(Duration.ofSeconds(1))
	               .sendKeys("abc")
	               .perform();
======================================================================================================================================================================

Pagefactory class is in selenuium   ----> import org.openqa.selenium.support.PageFactory;
	Page object model is a wonderful design pattern to abstract out Web Page elements and its actions from actual tests. This way tests do not have to worry about the creation/finding of WebElements. 


				import org.openqa.selenium.WebElement;
				import org.openqa.selenium.support.FindBy;
				import org.openqa.selenium.support.PageFactory;

				public class DynamicLoad1Page {

				    public DynamicLoad1Page(){
				        PageFactory.initElements(Driver.getDriver(), this);
				    }

				    @FindBy(xpath = "//button[.='Start']")
				    @CacheLookup
				    public WebElement startButton;

				    @FindAll(id = "loading")
				    @CacheLookup
				    public WebElement loadingBar;

				}


	@CacheLookup, as the name suggests helps us control when to cache a WebElement and when not to. This annotation, when applied over a WebElement, instructs Selenium to keep a cache of the WebElement instead of searching for the WebElement every time from the WebPage. This helps us save a lot of time.



	@FindBy(className = "classname")  == @FindBy(how = How.CLASS_NAME, using = "classname")

	@FindBys({ @FindBy(how = How.NAME, using = "username"), @FindBy(how = How.NAME, using = "password")})
	public List<WebElement> bothcriteria;

	@FindAll({ @FindBy(how = How.NAME, using = "username"), @FindBy(how = How.NAME, using = "password")})
    public List<WebElement> eithercriterion;


     @FindBys annotation is used in case elements need to match all of the given criteria
	 @FindAll annotation is used in case elements need to match at least one of the given criteria
===========================================================================================================================
For broken images, naturalWidth will be zero whereas it is non-zero for normal images.
if (img.getAttribute("naturalWidth").equals("0")) ===> broken

or can send HTTP:
- HttpGet request = new HttpGet(img.getAttribute("src"));
- HttpResponse response = client.execute(request);
- if (response.getStatusLine().getStatusCode() != 200)

==========================
=================================================
Expilicit Wait properties:
	1. Waits explicitly a time for overall wait process( timeout)
	2. checking webelements presence once every 5 seconds.  (pollingEvery(5sec.))
	3. ignoring certainExceptions if it happens --> ignoring(NoSuchElementException.class)
	4. Waiting certain Expected condition happens -- > wait.until(ExpectedConditions.elementToBeClickable(By.xpath("//a/h3")));

- Wait ---> interface with abstract method --->until()
- public class FluentWait<T> implements Wait<T> 
- public class WebDriverWait extends FluentWait<WebDriver>   ----> A specialization of FluentWait that uses WebDriver instances.

- after calling until() method we get the Webelement

WebDriverWait and FluentWait are almost identical. 
				WebDriverWait will ignore instances of NotFoundException that are encountered (thrown) by default in the until condition


WebElement button = new WebDriverWait(driver,10).pollingEvery(--).ignoring(---).until(ExpectedConditions.elementToBeClickable)
WebElement button = new FluentWait(driver).withTimeout(timeout).pollingEvery(time_interval).ignoring(_someExceptions).until(ExpectedConditions.elementToBeClickable)


- Specify timeout
- specify polling time
- specify ignoring exceptions
- specify wait until expected condition



WebDriverWait wait = new WebDriverWait(driver, Duration.ofSeconds(10))  --> IF NOT FOUND IN 10 secs --> throw Timeout exception
wait.until(ExpectedConditions.presenceOfElementLocated(By.linkText("Images")))

Bydefault, wait looks every 500 ms.
Fluent wait ---> polling(anyTime)

WebDriver can generally be said to have a blocking API. Because it is an out-of-process library that instructs the browser what to do, and because the web platform has an intrinsically asynchronous nature, WebDriver does not track the active, real-time state of the DOM. This comes with some challenges that we will discuss here.

From experience, most intermittent issues that arise from use of Selenium and WebDriver are connected to race conditions that occur between the browser and the user’s instructions 

The issue here is that the default page load strategy used in WebDriver listens for the document.readyState to change to "complete" before returning from the call to navigate. 

Fortunately, the normal instruction set available on the WebElement interface—such as WebElement.click and WebElement.sendKeys—are guaranteed to be synchronous, in that the function calls will not return (or the callback will not trigger in callback-style languages) until the command has been completed in the browser. The advanced user interaction APIs, Keyboard and Mouse, are exceptions as they are explicitly intended as “do what I say” asynchronous commands.

To overcome the problem of race conditions between the browser and your WebDriver script, most Selenium clients ship with a wait package. When employing a wait, you are using what is commonly referred to as an explicit wait.

Explicit waits are available to Selenium clients for imperative, procedural languages. They allow your code to halt program execution, or freeze the thread, until the condition you pass it resolves. The condition is called with a certain frequency until the timeout of the wait is elapsed. This means that for as long as the condition returns a falsy value, it will keep trying and waiting.

Since explicit waits allow you to wait for a condition to occur, they make a good fit for synchronising the state between the browser and its DOM, and your WebDriver script.

The wait condition can be customised to match your needs. Sometimes it is unnecessary to wait the full extent of the default timeout, as the penalty for not hitting a successful condition can be expensive.
The wait lets you pass in an argument to override the timeout:


- Wait ---> interface with abstract method --->until()
- public class FluentWait<T> implements Wait<T> 
- public class WebDriverWait extends FluentWait<WebDriver>   ----> A specialization of FluentWait that uses WebDriver instances.

WebDriverWait > FluentWait > Wait

WebDriverWait and FluentWait  ==> waiting webelement certain time(timeout) arguments + ignoring certain ExceptionS(NoSuchElementException) while waiting + polling in certain intervals + Expected condition occur within waiting time( before timout ends)

-- after until(Expected_condition)  we get returned Webelement

WebElement firstResult = new WebDriverWait(driver, Duration.ofSeconds(10))
							 .until(ExpectedConditions.elementToBeClickable(By.xpath("//ah3")));

Wait wait = new WebDriverWait(driver,10);  -----> Wait is interface with one method ==> until
WebElement button = wait.until(ExpectedConditions.elementToBeClickable(By.xpath("//ah3")));

Expected Conditions:  ====> look all these conditions and how they asserted to see the insight of Selenium asserts

presenceOfElementLocated(By locator)  ---> 
elementToBeClickable(final WebElement element)

titleContains(final String title)
urlToBe(final String url)
alertIsPresent()
numberOfWindowsToBe(final int expectedNumberOfWindows)
attributeToBe(final By locator, final String attribute,final String value)
frameToBeAvailableAndSwitchToIt(final WebElement frameLocator)
stalenessOf(final WebElement element)




Implicit wait:
driver.manage().timeouts().implicitlyWait(40);

There is a second type of wait that is distinct from explicit wait called implicit wait. By implicitly waiting, WebDriver polls the DOM for a certain duration when trying to find any element. This can be useful when certain elements on the webpage are not available immediately and need some time to load.

Implicit waiting for elements to appear is disabled by default and will need to be manually enabled on a per-session basis. Mixing explicit waits and implicit waits will cause unintended consequences, namely waits sleeping for the maximum time even if the element is available or condition is true.

Warning: Do not mix implicit and explicit waits. Doing so can cause unpredictable wait times. For example, setting an implicit wait of 10 seconds and an explicit wait of 15 seconds could cause a timeout to occur after 20 seconds.

An implicit wait is to tell WebDriver to poll the DOM for a certain amount of time when trying to find an element or elements if they are not immediately available. The default setting is 0, meaning disabled. Once set, the implicit wait is set for the life of the session.

================



-XPath contains text, sibling, ancestor, child, preceding, descendant, parent
 - non-brittle selenium find by statements ---> better xpath less btittle (dynamic)
 - we generally prefer to use id, name, class, etc., these locators. However, sometimes we could not find any of them in the DOM, and also sometimes locators of some elements change dynamically in the DOM`



-Generally, in some test automation engineer interviews, I asked about the difference between absolute and relative XPath. The answer is very easy.
	Absolute XPath in Selenium
	It is a direct way to locate an element.
	It is very brittle.
	It starts with a single slash “/” which means starting to search from the root.

	Relative XPath in Selenium
	Starts from the middle of the HTML DOM.
	Starts with a double slash “//” which means it can start to search anywhere in the DOM structure.
	Shorter than Absolute XPath.
	Less fragile.



- //span[normalize-space()=’About Software Test Academy’]  == //span[text()=’    About Software Test Academy     ’] ???? i think so

- Contains XPath in Selenium:
	. It is a very handy XPath Selenium locator, and sometimes it saves the life of a test automation engineer.
	. When an attribute of an element is dynamic, you can use contains() for the constant part of the web element but also use contains() in any condition when you need.

	. //tag[contains(@attribute, ‘value‘)]  --> //img[contains(@alt,’Book’)]

	. //span[contains(text(),’odamax’)]

- Starts-with Xpath Examples:
	/tag[starts-with(@attribute, ‘value‘)]


- OR --> case sensitive
	//*[@id=’user-message’ or @class=’form-control’]

- AND ---> case sensitibe
	//*[@id=’user-message’ and @class=’form-control’]



- 

//section[@id=’content’]//ancestor::div
//*[@id=’menu-main’]//descendant::li

//*[@id=’get-input’]/button//parent::form
//ul[@id=’menu-main’]/child::li

//*[@class=’panel-body’]//following-sibling::li
//div[@class=’fusion-sliding-bar-wrapper’]//following::section

//div[@class=’fusion-sliding-bar-wrapper’]//preceding::li
//div[@class=’fusion-sliding-bar-wrapper’]//preceding-sibling::li


=============

CSS EXAMPLES

( This is relative )

use > to go children 

shortcut for id     --> #      ---> #tabs-interval == div[id="interval"]   may be just [id="interval"] but i am not sure if this selenium takes this
shortcut for class  --> .

#tabs-interval > a:nth-child(4)  ---> start from element where id attribute = tabs-interval, look forth link element

.tabs-class > a:nth-child(4)      ---> start from element where class attribute = tabs-interval, look forth link element


body[class="users-page unified-theme"] > div


=============
Taking Screenshot in Selenium is a 3 Step process

Step 1) Convert web driver object to TakeScreenshot
	TakesScreenshot scrShot =(TakesScreenshot)webdriver;

Step 2) Call getScreenshotAs method to create image file

	File SrcFile=scrShot.getScreenshotAs(OutputType.FILE);

Step 3) Copy file to Desired Location

			TakesScreenshot scrShot =((TakesScreenshot)webdriver);
				
			//Call getScreenshotAs method to create image file

			File SrcFile=scrShot.getScreenshotAs(OutputType.FILE);

			//Move image file to new destination

			File DestFile=new File(fileWithPath);

			//Copy file at destination

			FileUtils.copyFile(SrcFile, DestFile);

or

public void tearDown(Scenario scenario) { if(scenario.isFailed()) {
//taking a screenshot
final byte[] screenshot = ((TakesScreenshot) Driver.getDriver()).getScreenshotAs(OutputType.BYTES);
//adding the screenshot to the report scenario.embed(screenshot, "image/png"); }


================
Discouraged behaviors
	Things to avoid when automating browsers with Selenium.
		- Captchas
			Completely Automated Public Turing test to tell Computers and Humans Apart, is explicitly designed to prevent automation, so do not try! There are two primary strategies to get around CAPTCHA checks:
				Disable CAPTCHAs in your test environment
				Add a hook to allow tests to bypass the CAPTCHA

		- File downloads
		- HTTP response codes
		- Gmail, email and Facebook logins
			Aside from being against the usage terms for these sites (where you risk having the account shut down), it is slow and unreliable.

			The ideal practice is to use the APIs that email providers offer, or in the case of Facebook the developer tools service which exposes an API for creating test accounts, friends and so forth. Although using an API might seem like a bit of extra hard work, you will be paid back in speed, reliability, and stability. The API is also unlikely to change, whereas webpages and HTML locators change often and require you to update your test framework.

		- Test dependency
			A common idea and misconception about automated testing is regarding a specific test order. Your tests should be able to run in any order, and not rely on other tests to complete in order to be successful.

		- Performance testing
		- Link spidering
		- Two Factor Authentication

==============

A general rule of thumb is that longer tests are more fragile and unreliable.

=======
File Upload
	File upload is possibke when:
		- "<input>" availebakle with accepting file path to uplaad: 
				driver.findElement(By.id("file-upload")).sendKeys("selenium-snapshot.jpg");
		- Pressing to the Uplaod button
			driver.findElement(By.id("file-submit")).submit();
The file upload dialog could be handled using Selenium, when the input element is of type file

=========
Working with cookies:
	Cookies are mostly used to recognise the user and load the stored information.
	- 	Add Cookie
		driver.manage().addCookie(new Cookie("key", "value"));

	- Get Named Cookie
		Cookie cookie1 = driver.manage().getCookieNamed("key");

	- Get All Cookies
		Set<Cookie> cookies = driver.manage().getCookies();

	- Delete Cookie
		driver.manage().deleteCookieNamed("key");

	- Delete All Cookies 
		driver.manage().deleteAllCookies();

===========

//Convenient
driver.get("https://selenium.dev");

//Longer way
driver.navigate().to("https://selenium.dev");

=======

//Store the ID of the original window
String originalWindow = driver.getWindowHandle();

Set<String> windowHandles = driver.getWindowHandles()

========


Create new window (or) new tab and switch 

// Opens a new tab and switches to new tab
driver.switchTo().newWindow(WindowType.TAB);

// Opens a new window and switches to new window
driver.switchTo().newWindow(WindowType.WINDOW);



Closing a window or tab

//Close the tab or window
driver.close();

//Switch back to the old tab or window
driver.switchTo().window(originalWindow);

	Forgetting to switch back to another window handle after closing a window will leave WebDriver executing on the now closed page, and will trigger a No Such Window Exception. You must switch back to a valid window handle in order to continue execution.



============

driver.quit();
	Quit will:

		Close all the windows and tabs associated with that WebDriver session
		Close the browser process
		Close the background driver process
		Notify Selenium Grid that the browser is no longer in use so it can be used by another session (if you are using Selenium Grid)


=========

TakeScreenshot

		WebDriver driver = new ChromeDriver();
        driver.get("http://www.example.com");
        File scrFile = ((TakesScreenshot)driver).getScreenshotAs(OutputType.FILE);
        FileUtils.copyFile(scrFile, new File("./image.png"));
        driver.quit();


TakeElementScreenshot

		WebDriver driver = new ChromeDriver();
	    driver.get("https://www.example.com");
	    WebElement element = driver.findElement(By.cssSelector("h1"));
	    File scrFile = element.getScreenshotAs(OutputType.FILE);
	    FileUtils.copyFile(scrFile, new File("./image.png"));
	    driver.quit();


===============


Execute Script:
	Executes JavaScript code snippet in the current context of a selected frame or window.

	 //Creating the JavascriptExecutor interface object by Type casting
      JavascriptExecutor js = (JavascriptExecutor)driver;

    //Button Element
      WebElement button =driver.findElement(By.name("btnLogin"));

    //Executing JavaScript to click on element
      js.executeScript("arguments[0].click();", button);

    //Get return value from script
      String text = (String) js.executeScript("return arguments[0].innerText", button);

    //Executing JavaScript directly
      js.executeScript("console.log('hello world')");

==============

Print Page
	Prints the current page within the browser.
	Note: This requires Chromium Browsers to be in headless mode

		import org.openqa.selenium.print.PrintOptions;

	    driver.get("https://www.selenium.dev");
	    printer = (PrintsPage) driver;

	    PrintOptions printOptions = new PrintOptions();
	    printOptions.setPageRanges("1-2");

	    Pdf pdf = printer.print(printOptions);
	    String content = pdf.getContent();
	  



========
 UI Testing - familiarity with writing browser-based tests, page-object-model, multi-browser, multi-threaded testing, synchronization (waiting for the browser to finish loading), etc.

• Performance / Load Testing - familiarity with (or intuitively understands) concepts and challenges associated with high-volume traffic production, and why it matters

• Test Identification - able to translate requirements and design into specific test cases to ensure correct function, not just happy path, but also negative, boundary, malformed inputs, and so on

• Defect Reporting - effectively communicate issues, steps to reproduce, impact, priority, possible causes, workarounds, etc.

• Risk Mitigation - able to identify project risks, their severity, likelihood, and how to prioritize testing to mitigate the highest risks first

 https://demo.seleniumeasy.com/bootstrap-dual-list-box-demo.html






 =============

Grid
	Want to run tests in parallel across multiple machines? Then, Grid is for you.

	Selenium Grid allows the execution of WebDriver scripts on remote machines by routing commands sent by the client to remote browser instances.

	Grid aims to:
			Provide an easy way to run tests in parallel on multiple machines
			Allow testing on different browser versions
			Enable cross platform testing

	When would you use a Selenium Grid?

			To run your tests in parallel, against different browser types, browser versions, operating systems
			To reduce the time needed to execute a test suite

=================

DragAndDrop

public class DragAndDrop {				

    WebDriver driver;			

    @Test		
    public void DragnDrop()					
    {		
         System.setProperty("webdriver.chrome.driver"," E://Selenium//Selenium_Jars//chromedriver.exe ");					
         driver= new ChromeDriver();					
         driver.get("http://demo.guru99.com/test/drag_drop.html");					
         
		//Element which needs to drag.    		
        	WebElement From=driver.findElement(By.xpath("//*[@id='credit2']/a"));	
         
         //Element on which need to drop.		
         WebElement To=driver.findElement(By.xpath("//*[@id='bank']/li"));					
         		
         //Using Action class for drag and drop.		
         Actions act=new Actions(driver);					

	//Dragged and dropped.		
         act.dragAndDrop(From, To).build().perform();		
	}		
}


==========

WebDriver driver=new RemoteWebDriver( hub's_url, capabilities)

ex:
	DesiredCapabilities caps=DesiredCapabilities.firefox(); //(chooses which browser)

	caps.setCapability(“platform”,”Windows 7”); 
	caps.setCapability(“version”,”38.0”);

	WebDriver driver=new RemoteWebDriver(new URL(“http://YOUR_USERNAME:YOUR_ACCESS_@ondemand.saucelabds.com:80/wd/hub”, caps)

==========


 How do you run your tests in multiple threads parallelly?
● Thread is like one process or instance of application run
● 4ways
1. We can create multiple cukesrunner with different tags Ex. cukerunner has tag “@Test”
	Smokerunner has @smoke
	Regression runner has @Regression
2. Create testng xml and add those runner class under one test
	Add all 3 runners in one xml
	Then next to verbose=2(on top of xml file) add “parallel=”classes” thread-count=”10”>
3. Then make sure our driver opens a remote WebDriver that is point to hub Add the code in driver class
4. Run the testng xml by itself or using maven.


========


Manage, coordinate, and execute all required testing activates in accordance to test plan. 


======


Which WebDriver implementation is fastest?
• HtmlUnitDriver implementation is fastest
• HtmlUnitDriver allows headless browser testing which is simply running your Selenium tests without a user
 
•

===========

Action is an interface with one method ---> perform()

Actions object will have a lot of actions and finally we call actions.build() which returbs Action where we call perform() to finish interaction

========

Selenium WebDriver - What is same origin policy? How you can avoid same origin policy?methods?

	The “Same Origin Policy” is introduced for security reason, and it ensures that content of your site will never be accessible by a script from another site. As per the policy, any code loaded within the browser can only operate within that website’s domain.

	To avoid “Same Origin Policy” proxy injection method is used, in proxy injection mode the Selenium Server acts as a client configured HTTP proxy , which sits between the browser and application under test and then masks the AUT under a fictional URL


=======


Assertions verify that the state of the application is same to what we are expecting. Selenium Assertions can be of three types: “assert”, “verify”, and ” waitFor”. When an “assert” fails, the test is aborted. When a “verify” fails, the test will continue execution, logging the failure.
A “waitFor” command waits for some condition to become true. 
		

=========

Assert --> if fails stop test excution
Verify is implemented using SoftAssert class. 

Hard Assertuins(Assert)
Soft Assertions (Verify Method)
Waitfor --> wiat for certain condition --> pass/ fail

=================



Selenium Hybrid Framework 
	Pageobjects
	TestCases
	TestData -> External TestData in xcel format
	Drivers --> Can use BonniGarcia
	Utilities -> ReadConfig.java, Reportin.java, XLUtils.java
	Logs  --> test.log, application.html
	Screenshots
	ConfigurationFiles in the root --> pom.xml, testng.xml, log4j.properties, extent-config.xml, run.bat



	apacche.poi Need Two 1. artifact_is = poi 2.artifact_is = poi-ooxml  dependencies for xcel file read write

	extent-reports dependency, from maveb repository

	Sikuli dependeny for some things selenium can't do i think



	- for logging two things 1. log4j mavn dependecy 2. create log4j.properties 
